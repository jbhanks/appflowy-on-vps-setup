---
#######################################
###########Postgres setup ################
#######################################
- name: Configure PostgreSQL YUM repository
  ansible.builtin.yum_repository:
    name: pgdg
    description: "PostgreSQL RPM repository"
    baseurl: "https://download.postgresql.org/pub/repos/yum/{{ PGVERSION }}/redhat/rhel-{{ ansible_distribution_major_version }}-x86_64/"
    enabled: yes
    gpgcheck: yes
    gpgkey: "https://download.postgresql.org/pub/repos/yum/keys/PGDG-RPM-GPG-KEY-RHEL"
    sslverify: yes

- name: Refresh DNF cache
  ansible.builtin.dnf:
    update_cache: yes

- name: Check if PostgreSQL module exists
  shell: dnf module list postgresql -q
  register: pg_module_check
  failed_when: false
  changed_when: false

- name: Disable built-in PostgreSQL module if available
  shell: dnf -qy module disable postgresql
  when: pg_module_check.rc == 0
  args:
    warn: false

- name: Install PostgreSQL packages (including CRB)
  dnf:
    name:
      - postgresql{{ PGVERSION }}-server
      - postgresql{{ PGVERSION }}-devel
      - postgresql{{ PGVERSION }}-contrib
      - epel-release
      - perl-IPC-Run
      - perl
      - libpq-devel
      - python3-devel
    state: present
    enablerepo: crb

- name: Create /mnt/database mount point
  file:
    path: /mnt/database
    state: directory

- name: Stop PostgreSQL service if it’s running
  ansible.builtin.systemd:
    name: postgresql-{{ PGVERSION }}
    state: stopped
  ignore_errors: yes     # in case it’s not yet installed or already stopped

- name: Ensure /mnt/database is not mounted
  mount:
    path: /mnt/database
    state: unmounted

- name: Remove any old /mnt/database fstab entry
  mount:
    path: /mnt/database
    state: absent

- name: Normalize HTZ_VOL_SIZE to GiB integer and bytes
  ansible.builtin.set_fact:
    _vol_gib: "{{ (HTZ_VOL_SIZE | string | regex_search('\\d+')) | int }}"
    _vol_bytes: "{{ ((HTZ_VOL_SIZE | string | regex_search('\\d+')) | int) * 1073741824 }}"

- name: Get list of block devices with size (bytes)
  ansible.builtin.command: lsblk -b -dn -o NAME,SIZE,TYPE
  register: block_devices
  changed_when: false

- name: Identify external device matching {{ _vol_gib }}G
  ansible.builtin.set_fact:
    external_device: "/dev/{{ item.split()[0] }}"
  loop: "{{ block_devices.stdout_lines }}"
  when:
    - item.split()[2] == 'disk'
    - (item.split()[1] | int) == _vol_bytes
  loop_control:
    label: "{{ item.split()[0] }}"

- name: Fail early if not found
  ansible.builtin.assert:
    that: external_device is defined
    fail_msg: "No disk matched {{ _vol_gib }}G (bytes={{ _vol_bytes }}). lsblk={{ block_devices.stdout_lines }}"

- name: Find if external device is mounted
  command: findmnt -nr -o TARGET --source={{ external_device }}
  register: external_mount
  failed_when: false
  changed_when: false
  when: external_device is defined

- name: Unmount external device if mounted
  ansible.posix.mount:
    path: "{{ external_mount.stdout }}"
    state: unmounted
  when:
    - external_device is defined
    - external_mount.stdout is defined
    - external_mount.stdout.startswith('/mnt')

- name: Format external device as XFS (force)
  community.general.filesystem:
    fstype: xfs
    dev:    "{{ external_device }}"
    force:  yes
  when: external_device is defined

# Get the UUID after formatting; retry briefly in case udev is slow  # Edit by ChatGPT
- name: Get UUID of volume  # Edit by ChatGPT
  ansible.builtin.command: blkid -s UUID -o value "{{ external_device }}"  # Edit by ChatGPT
  register: volume_uuid  # Edit by ChatGPT
  changed_when: false  # Edit by ChatGPT
  retries: 5  # Edit by ChatGPT
  delay: 1  # Edit by ChatGPT
  until: volume_uuid.stdout is match('^[A-Fa-f0-9-]+$')  # Edit by ChatGPT

# Canonical, single source of truth: mount via UUID and write fstab  # Edit by ChatGPT
- name: Mount "/mnt/database" by UUID and persist to fstab  # Edit by ChatGPT
  ansible.builtin.mount:
    path: /mnt/database
    src:  "UUID={{ volume_uuid.stdout }}"   # Edit by ChatGPT
    fstype: xfs
    opts: defaults,noatime
    dump: 1                                 # Edit by ChatGPT
    passno: 2                               # Edit by ChatGPT
    state: mounted

# Ensure the PostgreSQL data directory exists (fixes restorecon failure)  # Edit by ChatGPT
- name: Create data directory  # Edit by ChatGPT
  ansible.builtin.file:
    path: /mnt/database/data
    state: directory
    owner: postgres
    group: postgres
    mode: '0700'

# Safety check: ensure exactly one fstab line for this mountpoint  # Edit by ChatGPT
- name: Assert fstab has exactly one /mnt/database entry  # Edit by ChatGPT
  ansible.builtin.shell: "grep -cE '\\s/mnt/database\\s' /etc/fstab || true"  # Edit by ChatGPT
  register: fstab_count  # Edit by ChatGPT
  changed_when: false  # Edit by ChatGPT
  failed_when: (fstab_count.stdout | int) != 1  # Edit by ChatGPT

- name: Ensure systemd service drop-in directory exists
  file:
    path: "/etc/systemd/system/postgresql-{{ PGVERSION }}.service.d"
    state: directory
    mode: '0755'

- name: Configure PGDATA override in systemd drop-in
  copy:
    dest: "/etc/systemd/system/postgresql-{{ PGVERSION }}.service.d/override.conf"
    content: |
      [Service]
      Environment=PGDATA=/mnt/database/data
    mode: '0644'

- name: Reload systemd daemon
  systemd:
    daemon_reload: yes

- name: Label database directory for SELinux
  sefcontext:
    target: '/mnt/database/data(/.*)?'
    setype: postgresql_db_t
    state: present

- name: Restore SELinux context on database files
  command: restorecon -Rv /mnt/database/data

- name: Initialize PostgreSQL database
  become_user: postgres
  shell: |
    echo "{{ DBSUPERPASS }}" > /tmp/pg_super_pass.txt
    /usr/pgsql-{{ PGVERSION }}/bin/initdb -D /mnt/database/data \
      --username=postgres \
      --encoding=UTF8 \
      --locale=en_US.UTF-8 \
      --auth-local=scram-sha-256 \
      --auth-host=scram-sha-256 \
      --pwfile=/tmp/pg_super_pass.txt
  args:
    creates: /mnt/database/data/PG_VERSION

- name: Remove temporary password file
  file:
    path: /tmp/pg_super_pass.txt
    state: absent

- name: Start and enable PostgreSQL
  systemd:
    name: postgresql-{{ PGVERSION }}
    enabled: yes
    state: restarted

- name: Create .zshrc PG vars
  blockinfile:
    path: /home/{{ ADMINUSER }}/.zshrc.d/vars.zsh
    create: yes
    block: |
      # Postgres vars
      export PGDATA="/mnt/database/data"
      export PGHOST="localhost"
      export PGPORT="{{ DBPORT }}"
      export PGLOG="/var/log/pgsql"
    marker: ""

- name: Install psycopg2 using pip
  pip:
    name: psycopg2-binary
    state: latest
    executable: pip3

- name: Set postgres password
  become_user: postgres
  environment:
    PGPASSWORD: "{{ DBSUPERPASS }}"
  postgresql_user:
    name: postgres
    password: "{{ DBSUPERPASS }}"
    encrypted: yes

- name: Create application DB users
  become_user: postgres
  environment:
    PGPASSWORD: "{{ DBSUPERPASS }}"
  postgresql_user:
    name: "{{ item.user }}"
    password: "{{ DBUSERPASS }}"
    encrypted: yes
    state: present
  loop: "{{ POSTGRES.databases }}"
  when: POSTGRES.enabled | bool

- name: Create application databases
  become_user: postgres
  environment:
    PGPASSWORD: "{{ DBSUPERPASS }}"
  postgresql_db:
    name: "{{ item.name }}"
    owner: "{{ item.user }}"
    state: present
  loop: "{{ POSTGRES.databases }}"
  when: POSTGRES.enabled | bool

- name: Allow PostgreSQL port in UFW
  community.general.ufw:
    rule: allow
    port: "{{ DBPORT }}"
    proto: tcp

- name: Verify SELinux mapping for sshd port
  command: bash -lc "semanage port -l | grep -w ssh_port_t | grep -w 7312"
  register: selinux_ssh_port
  changed_when: false
  failed_when: false


#############################
#### DB certificates ##########
#############################

# - name: Variable check
#   debug:
#     msg: "Starting certificate generation, DOMAIN is: {{ DOMAIN }}"


# TLS certificate generation using shell-based OpenSSL commands to avoid chattr issues
- name: Create temporary directory for certificate generation
  ansible.builtin.file:
    path: /tmp/postgres-certs
    state: directory
    mode: '0750'
    owner: postgres
    group: postgres

- name: Generate CA private key
  ansible.builtin.command: openssl genrsa -out /tmp/postgres-certs/ca.key 2048
  args:
    creates: /tmp/postgres-certs/ca.key

- name: Generate CA self-signed certificate
  ansible.builtin.command: >
    openssl req -x509 -new -nodes
    -key /tmp/postgres-certs/ca.key
    -sha256 -days 3650
    -subj "/C={{ COUNTRY }}/O={{ DOMAIN }}/CN=MyDB Root CA"
    -out /tmp/postgres-certs/ca.crt
  args:
    creates: /tmp/postgres-certs/ca.crt

- name: Generate server private key
  ansible.builtin.command: openssl genrsa -out /tmp/postgres-certs/server.key 2048
  args:
    creates: /tmp/postgres-certs/server.key

- name: Generate server CSR
  ansible.builtin.command: >
    openssl req -new
    -key /tmp/postgres-certs/server.key
    -subj "/C={{ COUNTRY }}/O={{ DOMAIN }}/CN={{ DOMAIN }}/emailAddress={{ EMAIL }}"
    -out /tmp/postgres-certs/server.csr
  args:
    creates: /tmp/postgres-certs/server.csr

- name: Create server v3 extension file
  ansible.builtin.copy:
    dest: /tmp/postgres-certs/server_v3.ext
    content: |
      [ v3_req ]
      basicConstraints = CA:FALSE
      keyUsage = digitalSignature, keyEncipherment
      extendedKeyUsage = serverAuth
      subjectAltName = DNS:{{ DOMAIN }}
    owner: postgres
    group: postgres
    mode: '0644'

- name: Sign server certificate with CA
  ansible.builtin.command: >
    openssl x509 -req
    -in /tmp/postgres-certs/server.csr
    -CA /tmp/postgres-certs/ca.crt
    -CAkey /tmp/postgres-certs/ca.key
    -CAcreateserial
    -out /tmp/postgres-certs/server.crt
    -days 3650
    -sha256
    -extfile /tmp/postgres-certs/server_v3.ext
    -extensions v3_req
  args:
    creates: /tmp/postgres-certs/server.crt

- name: Generate client private key
  ansible.builtin.command: openssl genrsa -out /tmp/postgres-certs/postgresql.key 2048
  args:
    creates: /tmp/postgres-certs/postgresql.key

- name: Generate client CSR
  ansible.builtin.command: >
    openssl req -new
    -key /tmp/postgres-certs/postgresql.key
    -subj "/C={{ COUNTRY }}/O={{ DOMAIN }}/CN={{ DBUSERNAME }}"
    -out /tmp/postgres-certs/postgresql.csr
  args:
    creates: /tmp/postgres-certs/postgresql.csr

- name: Create client v3 extension file
  ansible.builtin.copy:
    dest: /tmp/postgres-certs/client_v3.ext
    content: |
      [ v3_req ]
      basicConstraints = CA:FALSE
      keyUsage = digitalSignature
      extendedKeyUsage = clientAuth
    owner: postgres
    group: postgres
    mode: '0644'

- name: Sign client certificate with CA
  ansible.builtin.command: >
    openssl x509 -req
    -in /tmp/postgres-certs/postgresql.csr
    -CA /tmp/postgres-certs/ca.crt
    -CAkey /tmp/postgres-certs/ca.key
    -CAcreateserial
    -out /tmp/postgres-certs/postgresql.crt
    -days 3650
    -sha256
    -extfile /tmp/postgres-certs/client_v3.ext
    -extensions v3_req
  args:
    creates: /tmp/postgres-certs/postgresql.crt

- name: Move certificates into PostgreSQL data directory
  ansible.builtin.copy:
    src: "/tmp/postgres-certs/{{ item }}"
    dest: "/mnt/database/data/{{ item }}"
    remote_src: yes
    owner: postgres
    group: postgres
    mode: "{{ '0600' if item.endswith('.key') else '0644' }}"
  loop:
    - ca.crt
    - ca.key
    - server.crt
    - server.key
    - postgresql.crt
    - postgresql.key

- name: Copy client key to /tmp for download
  ansible.builtin.copy:
    src: /mnt/database/data/postgresql.key
    dest: /tmp/postgresql.key
    remote_src: yes
    owner: "{{ APPUSER }}"
    group: "{{ APPUSER }}"
    mode: '0600'

- name: Copy client cert to /tmp for download
  ansible.builtin.copy:
    src: /mnt/database/data/postgresql.crt
    dest: /tmp/postgresql.crt
    remote_src: yes
    owner: "{{ APPUSER }}"
    group: "{{ APPUSER }}"
    mode: '0644'

- name: Copy root CA to /tmp for download
  ansible.builtin.copy:
    src: /mnt/database/data/ca.crt
    dest: /tmp/postgresql_root.crt
    remote_src: yes
    owner: "{{ APPUSER }}"
    group: "{{ APPUSER }}"
    mode: '0644'

#####################################
######### DB authentication ##########
#####################################
- name: Update postgresql.conf
  blockinfile:
    path: /mnt/database/data/postgresql.conf
    block: |
      listen_addresses = '*'
      port = {{ DBPORT }}
      ssl = on
      ssl_cert_file = 'server.crt'
      ssl_key_file = 'server.key'
      ssl_ca_file = 'ca.crt'
      ssl_min_protocol_version = 'TLSv1.3'
    marker: ""

- name: Configure pg_hba.conf
  blockinfile:
    path: /mnt/database/data/pg_hba.conf
    block: |
      local   all             all                                     scram-sha-256
      host    all             all             127.0.0.1/32            scram-sha-256
      host    all             all             {{ VPNIP }}/32            scram-sha-256
      host    all             all             {{ LOCALIP }}/32            scram-sha-256
      host    all             all             localhost               md5
    marker: ""

- name: Restart PostgreSQL after config
  systemd:
    name: postgresql-{{ PGVERSION }}
    state: restarted

- name: Allow PostgreSQL port in UFW
  community.general.ufw:
    rule: allow
    port: "{{ DBPORT }}"
    proto: tcp
#############################
# 1) Find & fetch backup_key.* under the home directory
- name: Find S3 backup key files
  find:
    paths: "/home/{{ ADMINUSER }}"
    patterns: "backup_key.*"
    recurse: no
  register: backup_keys

- name: Fetch each S3 backup key
  fetch:
    src: "{{ item.path }}"
    dest: "{{ local_secret_dir | default('../Secret') }}/"
    flat: yes
  loop: "{{ backup_keys.files }}"

# 2) Find & fetch postgresql* under /tmp
- name: Find PostgreSQL credential files in /tmp
  find:
    paths: /tmp
    patterns: "postgresql*"
    recurse: no
  register: pg_cred_files

- name: Fetch each PostgreSQL credential file
  fetch:
    src: "{{ item.path }}"
    dest: "{{ local_secret_dir | default('../Secret') }}/"
    flat: yes
  loop: "{{ pg_cred_files.files }}"
#############################